#!/usr/bin/env python
# This script requires Python 2.7

# Segue generator analyzes storyboards and generates a set of files with segue strings as constants

# Based on the idea from https://github.com/kluivers/storyboard-constants/blob/master/Scripts/generate_constants.py
# https://joris.kluivers.nl/blog/2014/02/10/storyboard-identifier-constants/

# Also inspired by
# https://bitbucket.org/nut_code_monkey/ssgenerator
# https://github.com/paulsamuels/SBConstants
# https://github.com/AliSoftware/SwiftGen


import sys
import os
import getopt
import itertools
import xml.etree.ElementTree as elTree


# useStoryboardIdentifierAsRestorationIdentifier = YES - then use storyboardIdentifier as restoration ID
# All segue types are frozenset(["custom", "push", "popover", "modal", "unwind", "relationship", "embed"])
# FIXME: need to distinguish between two segues which lead from one to the same view controller


# Processes the whole storyboard and returns controller-to-segues mapping
def process_storyboard(storyboard):
    # Set up the nodes we're fetching
    nodes_to_fetch = "viewController", "navigationController", "tabBarController"
    # Get storyboard's root element and map controller nodes with their identifiers
    root = elTree.parse(storyboard).getroot()
    nodes = itertools.chain.from_iterable([root.findall(".//" + node) for node in nodes_to_fetch])
    ctl_mapping = {value.get("id"): value for value in nodes}
    node_mapping = {}
    # Segues and storyboard identifiers are contained inside view controllers
    for ctl_id in ctl_mapping:
        controller = ctl_mapping[ctl_id]
        destinations = get_segue_destinations(controller, ctl_mapping)
        if len(destinations) > 0:
            node_mapping[controller] = destinations
    return node_mapping


# Maps segues to their actual destinations
def get_segue_destinations(controller, mapping):
    # Choose only those controllers which have custom classes assigned, skip all the rest otherwise
    segues = controller.findall(".//*segue") if controller.get("customClass") is not None else ()
    nodes = {}
    for segue in segues:
        segue_id = segue.get("identifier")
        # We're skipping all segues which do not have identifiers
        if segue_id is not None:
            node = get_actual_segue_destination(segue, mapping)
            # Save self as destination for an unwind segue, received node otherwise
            # Inspect unwind action for unwind segue and get the modified selector
            nodes[segue] = controller if node is None else node
    return nodes


# Returns None for unwind segues or actual segue's destination to support correct naming.
def get_actual_segue_destination(segue, mapping):
    destination_id = segue.get("destination")
    if destination_id not in mapping:
        # Unwind segue detected
        return None
    else:
        destination = mapping[destination_id]
        # For nav controller - relationship segue + "relationship" key + destination gives the root view controller
        if destination.tag == "navigationController":
            next_segue = destination.find(".//*segue[@kind='relationship'][@relationship='rootViewController']")
            return get_actual_segue_destination(next_segue, mapping)
        else:
            # For tab bar controller - relationship segue + "relationship" key + destination gives the tab
            # For embed segue - inspect if there's an id and generate embed
            return destination


# Strips extra characters from view controller's custom class
def strip_name_extras(string, prefix, suffix):
    string = string[len(prefix):] if string.startswith(prefix) and len(prefix) > 0 else string
    return string[:-len(suffix)] if string.endswith(suffix) and len(suffix) > 0 else string


# Strips extra characters
def strip_selector_extras(string):
    return string[:-1] if len(string) > 1 else string


# Generates a prefixed name based on the segue's action
def prefixed_name_for_action(name, action):
    prefix = action if action in ("embed", "unwind") else "to"
    return name if name.startswith(prefix) else prefix + name


# Writes a file with segue struct declarations
def write_header(file_name, identifiers, prefix, suffix):
    with open(file_name + ".h", "w+") as header:
        header.write("/* This file is generated by a script. Any custom changes will be lost */\n\n")
        header.write("@class NSString;\n\n")
        header.write("/* Segue identifier constants */\n\n")

        for src_node in identifiers:
            structs_name = strip_name_extras(src_node.get("customClass"), prefix, suffix) + "Segues"
            # Begin a new structure
            header.write("extern const struct " + structs_name + " {\n")
            # Save the collection of sub-nodes
            sub_nodes = identifiers[src_node]
            for segue_node in sub_nodes:
                dest_node = sub_nodes[segue_node]
                action = segue_node.get("kind")
                # Get action for unwind segues, use destination otherwise
                if src_node == dest_node:
                    field = strip_selector_extras(segue_node.get("unwindAction"))
                else:
                    field = strip_name_extras(dest_node.get("customClass"), prefix, suffix)
                # Write down structure's field
                header.write("    __unsafe_unretained NSString *const "+prefixed_name_for_action(field, action)+";\n")
            # Finalize the structure's declaration
            header.write("} " + structs_name + ";\n\n")
        header.write("\n")
        header.close()


# Writes a file with segue struct implementations
def write_impl(file_name, identifiers, prefix, suffix):
    with open(file_name + ".m", "w+") as impl:
        impl.write("/* This file is generated by a script. Any custom changes will be lost */\n\n")
        impl.write("#import <Foundation/Foundation.h>\n")
        impl.write("#import \"" + os.path.basename(file_name) + ".h\"\n\n")
        impl.write("/* Segue identifier constants */\n\n")

        for src_node in identifiers:
            structs_name = strip_name_extras(src_node.get("customClass"), prefix, suffix) + "Segues"
            # Begin a new structure
            impl.write("const struct " + structs_name + " " + structs_name + " = {\n")
            # Save the collection of sub-nodes
            sub_nodes = identifiers[src_node]
            for segue_node in sub_nodes:
                dest_node = sub_nodes[segue_node]
                action = segue_node.get("kind")
                segue_id = segue_node.get("identifier")
                # Get action for unwind segues, use destination otherwise
                if src_node == dest_node:
                    field_name = strip_selector_extras(segue_node.get("unwindAction"))
                else:
                    field_name = strip_name_extras(dest_node.get("customClass"), prefix, suffix)
                # Write down structure's field
                impl.write("    ." + prefixed_name_for_action(field_name, action) + " = @\"" + segue_id + "\",\n")
            # Finalize the structure's declaration
            impl.write("};\n\n")
        impl.write("\n")
        impl.close()


# writes an Objective-C version of segues
def write_objc(file_name, identifiers, prefix, suffix):
    write_header(file_name, identifiers, prefix, suffix)
    write_impl(file_name, identifiers, prefix, suffix)


# Displays the information about script's usage
def usage(code):
    print "Usage: " + os.path.basename(__file__) + " [storyboard 1] ... [storyboard N]"
    sys.exit(code)


# Main routine
def main(argv):
    # Default values
    opts = args = prefix = ""
    out_folder = "."
    suffix = "ViewController"
    # Test for minimal python version
    min_version = (2, 7)
    if sys.version_info < min_version:
        print "Python %s.%s or later is required\n" % min_version
        sys.exit(1)
    # Get command line options
    try:
        opts, args = getopt.getopt(argv, "ho:p:s:w")
    except getopt.GetoptError:
        usage(1)
    # Parse supported options
    for opt, arg in opts:
        if opt == "-h":
            usage(0)
        elif opt == "-o":
            out_folder = arg
        elif opt == "-p":
            prefix = arg
        elif opt == "-s":
            suffix = arg
        elif opt == "-w":
            print "Swift support is not implemented yet"
        else:
            usage(1)
    # Process storyboards
    for arg in args:
        filename = os.path.basename(arg)
        write_objc(os.path.join(out_folder, filename), process_storyboard(arg), prefix, suffix)


if __name__ == "__main__":
    main(sys.argv[1:])


# For Xcode support?
# count = os.environ["SCRIPT_INPUT_FILE_COUNT"]
# for n in range(int(count)):
#     process_storyboard(os.environ["SCRIPT_INPUT_FILE_" + str(n)])
